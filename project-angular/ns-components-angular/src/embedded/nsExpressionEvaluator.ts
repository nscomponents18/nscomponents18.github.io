export const NSExpressionEvaluatorCode = "var nsModuleExport = function(root,name,prototype)\r\n\t{\r\n\t\tif(typeof exports === 'object' && typeof module === 'object')\r\n\t\t{\r\n\t\t\tmodule.exports[name] = prototype;\r\n\t\t}\r\n\t\telse if (typeof define === \"function\" && define.amd)\r\n\t\t{\r\n\t\t\tdefine(name,[], function () {return prototype;});\r\n\t\t}\r\n\t\telse if(typeof exports === 'object')\r\n\t\t{\r\n\t\t\texports[name] = prototype;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\troot[name] = prototype;\r\n\t\t}\r\n\t};var nsIsWeb = function(root)\r\n\t{\r\n\t\tif(typeof exports === 'object' && typeof module === 'object')\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\telse if (typeof define === \"function\" && define.amd)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\telse if(typeof exports === 'object')\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn true;\r\n\t\t}\r\n\t};if(!nsIsWeb())\r\n\t\t{\r\nvar nsutilRef = require('./nsUtil.min.js');\r\nvar NSUtil = nsutilRef.NSUtil;\r\n\r\n\t\t}\r\nvar NSExpressionEvaluator = (function() {\r\n    function NSExpressionEvaluator(setting) {\r\n        var self = this;\r\n        var oldExpression = null;\r\n        var nodes = [];\r\n        if(!setting) {\r\n            setting = {};\r\n        }\r\n        var config = {\r\n            throwErrorForUndefined: setting.throwErrorForUndefined | false\r\n        };\r\n\t\tvar isCustomException = false;\r\n\t\t\r\n\t\tvar operatorFunctions = {\r\n            '+': function(left, right) { return left + right; },\r\n            '-': function(left, right) { return left - right; },\r\n            '*': function(left, right) { return left * right; },\r\n            '/': function(left, right) { return left / right; },\r\n            '%': function(left, right) { return left % right; },\r\n            '**': function(left, right) { return Math.pow(left, right); },\r\n            '^': function(left, right) { return left ^ right; },\r\n            '&': function(left, right) { return left & right; },\r\n            '|': function(left, right) { return left | right; },\r\n            '<<': function(left, right) { return left << right; },\r\n            '>>': function(left, right) { return right >> right; },\r\n            '>': function(left, right) { return left > right; },\r\n            '<': function(left, right) { return left < right; },\r\n            '>=': function(left, right) { return left >= right; },\r\n            '<=': function(left, right) { return left <= right; },\r\n            '===': function(left, right) { return left === right; },\r\n            '!==': function(left, right) { return left !== right; },\r\n            '&&': function(left, right) { return left && right; },\r\n            '||': function(left, right) { return left || right; }\r\n        };\r\n\r\n        var operatorConfig = {\r\n            '.': { precedence: 6, associativity: 'L' },\r\n            '[': { precedence: 6, associativity: 'L' },\r\n            ']': { precedence: 6, associativity: 'L' },\r\n            '+': { precedence: 3, associativity: 'L' },\r\n            '-': { precedence: 3, associativity: 'L' },\r\n            '*': { precedence: 4, associativity: 'L' },\r\n            '/': { precedence: 4, associativity: 'L' },\r\n            '%': { precedence: 4, associativity: 'L' },\r\n            '**': { precedence: 5, associativity: 'R' },\r\n            '^': { precedence: 2, associativity: 'L' },\r\n            '&': { precedence: 1, associativity: 'L' },\r\n            '|': { precedence: 1, associativity: 'L' },\r\n            '<<': { precedence: 2, associativity: 'L' },\r\n            '>>': { precedence: 2, associativity: 'L' },\r\n            '>': { precedence: 2, associativity: 'L' },\r\n            '<': { precedence: 2, associativity: 'L' },\r\n            '>=': { precedence: 2, associativity: 'L' },\r\n            '<=': { precedence: 2, associativity: 'L' },\r\n            '===': { precedence: 1, associativity: 'L' },\r\n            '!==': { precedence: 1, associativity: 'L' },\r\n            '&&': { precedence: 0, associativity: 'L' },\r\n            '||': { precedence: 0, associativity: 'L' }\r\n        };\r\n\r\n\r\n        var evaluate = function(expression,model) {\r\n\t\t\tisCustomException = false;\r\n\t\t\ttry {\r\n\t\t\t\t if(expression !== oldExpression || !nodes || nodes.length === 0) {\r\n\t\t\t\t\tsetExpression(expression);\r\n\t\t\t\t }\r\n\t\t\t\t var val = getValue(model,nodes);\r\n\t\t\t\t return val;\r\n\t\t\t}\r\n\t\t\tcatch(error) {\r\n\t\t\t\tif(!isCustomException) {\r\n\t\t\t\t\t//this logic if worst case some scenario is not covered by the logic of NSExpressionEvaluator but for most of the basic scenario the below code is not required\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tvar func = new Function('model', `with (model) { return ${expression}; }`);\r\n\t\t\t\t\t\tvar val = func(model);\r\n\t\t\t\t\t\treturn val;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcatch(innerError) {\r\n\t\t\t\t\t\tthrow new Error(innerError);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tisCustomException = true;\r\n\t\t\t\t\tthrow error;\r\n\t\t\t\t}\r\n\t\t\t}\r\n        };\r\n\r\n        var setExpression = function(expression) {\r\n            var tokens = getTokens(expression);\r\n            //console.log(tokens);\r\n            nodes = parseTokens(tokens);\r\n            //console.log(nodes);\r\n            oldExpression = expression;\r\n        };\r\n\r\n        var getTokens = function(expression) {\r\n\t\t\tvar tokens = [];\r\n\t\t\tvar current = '';\r\n\t\t\tvar addToken = function() {\r\n\t\t\t\tif (current.length > 0) {\r\n\t\t\t\t\ttokens.push(current);\r\n\t\t\t\t\tcurrent = '';\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\tvar isWithinBrackets = false;\r\n\t\t\tfor (var i = 0; i < expression.length; i++) {\r\n\t\t\t\tvar char = expression[i];\r\n\t\t\t\tif (char === ' ' || char === '\\t' || char === '\\n') {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tif([','].includes(char) && isWithinBrackets) {\r\n\t\t\t\t\taddToken();\r\n\t\t\t\t\t//for now not adding , in tokens\r\n\t\t\t\t\t/*current = char;\r\n\t\t\t\t\taddToken();*/\r\n\t\t\t\t} else if (isDigit(char)) {\r\n\t\t\t\t\tcurrent += char;\r\n\t\t\t\t} else if (isLetter(char) || (current.length > 0 && isLetter(current[0]) && char === '_')) {\r\n\t\t\t\t\tcurrent += char;\r\n\t\t\t\t} else if (char === '(' || char === ')') {\r\n\t\t\t\t\tif(char === '(') {\r\n\t\t\t\t\t\tisWithinBrackets = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tisWithinBrackets = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (current.length > 0) {\r\n\t\t\t\t\t\ttokens.push(current);\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttokens.push(char);\r\n\t\t\t\t\tcurrent = '';\r\n\t\t\t\t} else if (isOperator(expression, i)) {\r\n\t\t\t\t\taddToken();\r\n\t\t\t\t\tvar multiCharOp = '';\r\n\t\t\t\t\t// Check for multi-character operators\r\n\t\t\t\t\tif (i + 2 < expression.length) {\r\n\t\t\t\t\t\tmultiCharOp = expression.substr(i, 3);\r\n\t\t\t\t\t\tif (multiCharOp === '===' || multiCharOp === '!==') {\r\n\t\t\t\t\t\t\ttokens.push(multiCharOp);\r\n\t\t\t\t\t\t\ti += 2;\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (i + 1 < expression.length) {\r\n\t\t\t\t\t\tmultiCharOp = expression.substr(i, 2);\r\n\t\t\t\t\t\tif (['==', '!=', '<=', '>=', '&&', '||', '**', '<<', '>>'].includes(multiCharOp)) {\r\n\t\t\t\t\t\t\ttokens.push(multiCharOp);\r\n\t\t\t\t\t\t\ti += 1;\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttokens.push(char);\r\n\t\t\t\t} else if (char === '\"' || char === '\\'') {\r\n\t\t\t\t\tvar quoteType = char;\r\n\t\t\t\t\tcurrent = quoteType;\r\n\t\t\t\t\ti++;\r\n\t\t\t\t\twhile (i < expression.length && expression[i] !== quoteType) {\r\n\t\t\t\t\t\tcurrent += expression[i++];\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcurrent += quoteType;\r\n\t\t\t\t\ttokens.push(current);\r\n\t\t\t\t\tcurrent = '';\r\n\t\t\t\t} else if (char === '[' || char === ']' || char === '(' || char === ')' || char === '.') {\r\n\t\t\t\t\taddToken();\r\n\t\t\t\t\ttokens.push(char);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\taddToken();\r\n\t\t\treturn tokens;\r\n\t\t};\r\n\r\n\r\n        var parseTokens = function(tokens) {\r\n\t\t\tvar outputQueue = [];\r\n\t\t\tvar operatorStack = [];\r\n\r\n\t\t\tfor (var i = 0; i < tokens.length; i++) {\r\n\t\t\t\tvar token = tokens[i];\r\n\t\t\t\tif (!isNaN(parseFloat(token))) {\r\n\t\t\t\t\toutputQueue.push(getNode('Number', parseFloat(token)));\r\n\t\t\t\t} else if (isQuotedString(token)) {\r\n\t\t\t\t\toutputQueue.push(getNode('String', token));\r\n\t\t\t\t} else if (isValidStringIdentifier(token)) {\r\n\t\t\t\t\t if (tokens[i+1] === '(') {\r\n\t\t\t\t\t\t// Handle function call\r\n\t\t\t\t\t\tvar funcName = token;\r\n\t\t\t\t\t\tvar args = [];\r\n\t\t\t\t\t\ti += 2; // skip function name and '('\r\n\t\t\t\t\t\twhile (tokens[i] !== ')') {\r\n\t\t\t\t\t\t\targs.push(tokens[i]);\r\n\t\t\t\t\t\t\ti++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvar paramQueue = [];\r\n\t\t\t\t\t\tif(args.length > 0) {\r\n\t\t\t\t\t\t\tparamQueue = parseTokens(args);\r\n\t\t\t\t\t\t\tconsole.log(args, paramQueue);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\toutputQueue.push(getNode('FunctionCall', funcName, null, null, paramQueue));\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\ti = handleVariableAndAccess(i, tokens, outputQueue);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (operatorConfig[token]) {\r\n\t\t\t\t\thandleOperators(token, operatorStack, outputQueue);\r\n\t\t\t\t} else if (token === '(') {\r\n\t\t\t\t\toperatorStack.push(getNode('Operator', token));\r\n\t\t\t\t} else if (token === ')') {\r\n\t\t\t\t\ti = handleClosingParenthesis(operatorStack, outputQueue, i);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\twhile (operatorStack.length > 0) {\r\n\t\t\t\toutputQueue.push(operatorStack.pop());\r\n\t\t\t}\r\n\t\t\treturn outputQueue;\r\n\t\t};\r\n\r\n\t\tvar handleVariableAndAccess = function(i, tokens, outputQueue) {\r\n\t\t\tvar variable = tokens[i];\r\n\t\t\twhile (i + 1 < tokens.length && (tokens[i + 1] === '.' || tokens[i + 1] === '[')) {\r\n\t\t\t\t//skip the '.' and move to the property name\r\n\t\t\t\tif (tokens[i + 1] === '.') {\r\n\t\t\t\t\ti += 2; \r\n\t\t\t\t\tvariable += '.' + tokens[i];\r\n\t\t\t\t//skip the '[' and move to the index\r\n\t\t\t\t} else if (tokens[i + 1] === '[') {\r\n\t\t\t\t\ti += 2;\r\n\t\t\t\t\t//skip past the ']'\r\n\t\t\t\t\tvariable += '[' + tokens[i] + ']';\r\n\t\t\t\t\ti++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\toutputQueue.push(getNode('Variable', variable));\r\n\t\t\treturn i;\r\n\t\t};\r\n\r\n\t\tvar handleOperators = function(token, operatorStack, outputQueue) {\r\n\t\t\tvar precedence = operatorConfig[token].precedence;\r\n\t\t\tvar associativity = operatorConfig[token].associativity;\r\n\t\t\twhile (operatorStack.length > 0 &&\r\n\t\t\t\t   operatorConfig[operatorStack[operatorStack.length - 1].value].precedence >= precedence &&\r\n\t\t\t\t   associativity === 'L') {\r\n\t\t\t\toutputQueue.push(operatorStack.pop());\r\n\t\t\t}\r\n\t\t\toperatorStack.push(getNode('Operator', token));\r\n\t\t};\r\n\r\n\t\tvar handleClosingParenthesis = function(operatorStack, outputQueue, i) {\r\n\t\t\twhile (operatorStack.length > 0 && operatorStack[operatorStack.length - 1].value !== '(') {\r\n\t\t\t\toutputQueue.push(operatorStack.pop());\r\n\t\t\t}\r\n\t\t\toperatorStack.pop();\r\n\t\t\treturn i;\r\n\t\t};\r\n\r\n        var getValue = function(model,paramNodes) {\r\n            var stack = [];\r\n\r\n            for(var count = 0;count < paramNodes.length;count++) {\r\n\t\t\t\tvar node = paramNodes[count];\r\n                if (node.type === 'Number') {\r\n                    stack.push(node.value);\r\n                } else if (node.type === 'String') {\r\n\t\t\t\t\t//removing quotes\r\n                    stack.push(node.value.slice(1, -1));  \r\n                } else if (node.type === 'Variable') {\r\n\t\t\t\t\tvar value = getVariableValue(model,node);\r\n\t\t\t\t\t//console.log(value,val);\r\n                    stack.push(value);\r\n                } else if (node.type === 'FunctionCall') {\r\n\t\t\t\t\tvar func = node.value;\r\n\t\t\t\t\tif (!isFunction(func)) {\r\n\t\t\t\t\t\tfunc = model[node.value];\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (isFunction(func)) {\r\n\t\t\t\t\t\tvar args = [];\r\n\t\t\t\t\t\tif(node.params && node.params.length > 0) {\r\n\t\t\t\t\t\t\tfor(var paramCount = 0;paramCount < node.params.length;paramCount++) {\r\n\t\t\t\t\t\t\t\tvar param = node.params[paramCount];\r\n\t\t\t\t\t\t\t\tvar paramVal = getValue(model,[param]);\r\n\t\t\t\t\t\t\t\targs.push(paramVal);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tstack.push(func.apply(null, args));\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthrowException(`Function ${node.value} is not defined`);\r\n\t\t\t\t\t\tstack.push(undefined);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (node.type === 'Operator') {\r\n                    var right = stack.pop();\r\n                    var left = stack.pop();\r\n\t\t\t\t\tif(operatorFunctions[node.value]) {\r\n                        stack.push(operatorFunctions[node.value](left,right));\r\n                    }\r\n                }\r\n            };\r\n\r\n            return stack.pop();\r\n        };\r\n\t\t\r\n\t\tvar getVariableValue = function(model,node) {\r\n\t\t\tvar value = model;\r\n\t\t\tvar prevValue = null;\r\n\t\t\tvar parts = node.value.split(/\\.|\\[|\\]/).filter(Boolean);\r\n\t\t\tfor(var count = 0;count < parts.length;count++) {\r\n\t\t\t\tvar part = parts[count];\r\n\t\t\t\tprevValue = value;\r\n\t\t\t\tif (!isNaN(part)) {\r\n\t\t\t\t\tvalue = value[parseInt(part)];\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvalue = value[part];\r\n\t\t\t\t}\r\n\t\t\t\tif(isUndefined(value)) {\r\n\t\t\t\t\tthrowException(`Value is undefined for ${part} in ${serializableToJson(prevValue)}`);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\treturn value;\r\n\t\t};\r\n\r\n        var getNode = function(type, value, left, right, params) {\r\n            return {type, value, left, right, params};\r\n        };\r\n\t\t\r\n\t\tvar throwException = function(message) {\r\n\t\t\tif(config.throwErrorForUndefined) {\r\n\t\t\t\tisCustomException = true;\r\n\t\t\t\tthrow new Error(message);\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n        //utility methods\r\n        var isDigit = function(val) {\r\n            return val >= '0' && val <= '9';\r\n        };\r\n        var isLetter = function(val) {\r\n            return ((val >= 'a' && val <= 'z') || (val >= 'A' && val <= 'Z') || val === '_');\r\n        };\r\n        var isOperator = function(expr, index) {\r\n\t\t\tvar nextChar = expr[index + 1];\r\n\t\t\tvar currentChar = expr[index];\r\n\t\t\tvar twoCharOp = currentChar + (nextChar || ''); // create the two-character string\r\n\r\n\t\t\t// Check for two-character operators\r\n\t\t\tif (['**', '<<', '>>', '&&', '||', '==', '!=', '<=', '>='].includes(twoCharOp)) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\t// Check for single-character operators\r\n\t\t\tif (\"+-*/%<>=!&|^\".includes(currentChar)) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t};\r\n\t\tvar isQuotedString = function(val) {\r\n\t\t\tif (val.length >= 2) {\r\n\t\t\t\tvar startChar = val[0];\r\n\t\t\t\tvar endChar = val[val.length - 1];\r\n\r\n\t\t\t\tif ((startChar === '\"' || startChar === \"'\") && startChar === endChar) {\r\n\t\t\t\t\t// Check for the presence of the quote character in the middle of the string\r\n\t\t\t\t\tfor (let i = 1; i < val.length - 1; i++) {\r\n\t\t\t\t\t\tif (val[i] === startChar) {\r\n\t\t\t\t\t\t\t//found the starting quote character in the middle\r\n\t\t\t\t\t\t\treturn false; \r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t};\r\n\t\t\r\n\t\tvar isValidStringIdentifier = function(val) {\r\n\t\t\tif (val.length > 0) {\r\n\t\t\t\tvar firstChar = val[0];\r\n\t\t\t\tif (!(firstChar >= 'a' && firstChar <= 'z') && !(firstChar >= 'A' && firstChar <= 'Z') && firstChar !== '_') {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\tfor (let i = 1; i < val.length; i++) {\r\n\t\t\t\t\tvar char = val[i];\r\n\t\t\t\t\tif (!(char >= 'a' && char <= 'z') && !(char >= 'A' && char <= 'Z') && !(char >= '0' && char <= '9') && char !== '_') {\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t};\r\n\r\n        var isUndefined = function(val) {\r\n            return (typeof val === 'undefined');\r\n        };\r\n\t\tvar isFunction = function(val) {\r\n            return (typeof val === 'function');\r\n        };\r\n        var serializableToJson = function(val) {\r\n            try {\r\n                var res = JSON.stringify(val);\r\n                return res;\r\n            } catch (e) {\r\n                console.debug(e);\r\n            }\r\n            return val;\r\n        };\r\n\r\n        self.evaluate = evaluate;\r\n        self.setExpression = setExpression;\r\n    };\r\n    return NSExpressionEvaluator;\r\n})();\r\nnsModuleExport(this,\"NSExpressionEvaluator\",NSExpressionEvaluator);";