export const NSPromiseCode = "var nsModuleExport = function(root,name,prototype)\r\n\t{\r\n\t\tif(typeof exports === 'object' && typeof module === 'object')\r\n\t\t{\r\n\t\t\tmodule.exports[name] = prototype;\r\n\t\t}\r\n\t\telse if (typeof define === \"function\" && define.amd)\r\n\t\t{\r\n\t\t\tdefine(name,[], function () {return prototype;});\r\n\t\t}\r\n\t\telse if(typeof exports === 'object')\r\n\t\t{\r\n\t\t\texports[name] = prototype;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\troot[name] = prototype;\r\n\t\t}\r\n\t};var nsIsWeb = function(root)\r\n\t{\r\n\t\tif(typeof exports === 'object' && typeof module === 'object')\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\telse if (typeof define === \"function\" && define.amd)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\telse if(typeof exports === 'object')\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn true;\r\n\t\t}\r\n\t};if(!nsIsWeb())\r\n\t\t{\r\nvar nsutilRef = require('./nsUtil.min.js');\r\nvar NSUtil = nsutilRef.NSUtil;\r\n\r\n\t\t}\r\n//https://github.com/YahooArchive/ypromise/blob/master/promise.js\r\nvar Promise = (function () \r\n{\r\n\tfunction Resolver() \r\n\t{\r\n\t\tthis._callbacks = [];\r\n\t\tthis._errbacks = [];\r\n\t\tthis._status = 'pending';\r\n\t\tthis._result = null;\r\n\t}\r\n\t\r\n\tResolver.prototype.fulfill = function (value) \r\n    {\r\n\t\tvar status = this._status;\r\n        if (status === 'pending' || status === 'accepted') \r\n        {\r\n            this._result = value;\r\n            this._status = 'fulfilled';\r\n        }\r\n        if (this._status === 'fulfilled') \r\n        {\r\n            this._notify(this._callbacks, this._result);\r\n            this._callbacks = [];\r\n            this._errbacks = null;\r\n        }\r\n    };\r\n    \r\n    Resolver.prototype.reject = function (reason) \r\n    {\r\n    \tvar status = this._status;\r\n        if (status === 'pending' || status === 'accepted') \r\n        {\r\n            this._result = reason;\r\n            this._status = 'rejected';\r\n        }\r\n        if (this._status === 'rejected') \r\n        {\r\n            this._notify(this._errbacks, this._result);\r\n            this._callbacks = null;\r\n            this._errbacks = [];\r\n        }\r\n    };\r\n    \r\n    Resolver.prototype.resolve = function (value) \r\n    {\r\n        if (this._status === 'pending') \r\n        {\r\n            this._status = 'accepted';\r\n            this._value = value;\r\n            if ((this._callbacks && this._callbacks.length) || this._errbacks && this._errbacks.length)\r\n            {\r\n                this._unwrap(this._value);\r\n            }\r\n        }\r\n    };\r\n    \r\n    Resolver.prototype._unwrap = function (value) \r\n    {\r\n        var self = this, unwrapped = false, then;\r\n        if (!value || (typeof value !== 'object' && typeof value !== 'function')) \r\n        {\r\n            self.fulfill(value);\r\n            return;\r\n        }\r\n        try \r\n        {\r\n            then = value.then;\r\n            if (typeof then === 'function') \r\n            {\r\n                then.call(value, function (value) \r\n                {\r\n                    if (!unwrapped) \r\n                    {\r\n                        unwrapped = true;\r\n                        self._unwrap(value);\r\n                    }\r\n                }, \r\n                function (reason) \r\n                {\r\n                    if (!unwrapped) \r\n                    {\r\n                        unwrapped = true;\r\n                        self.reject(reason);\r\n                    }\r\n                });\r\n            } \r\n            else \r\n            {\r\n                self.fulfill(value);\r\n            }\r\n        } \r\n        catch (e) \r\n        {\r\n            if (!unwrapped) \r\n            {\r\n                self.reject(e);\r\n            }\r\n        }\r\n    };\r\n\r\n    Resolver.prototype._addCallbacks = function (callback, errback) \r\n    {\r\n        var callbackList = this._callbacks,\r\n            errbackList  = this._errbacks;\r\n        if (callbackList) \r\n        {\r\n            callbackList.push(callback);\r\n        }\r\n        if (errbackList) \r\n        {\r\n            errbackList.push(errback);\r\n        }\r\n        switch (this._status) \r\n        {\r\n            case 'accepted':\r\n                this._unwrap(this._value);\r\n                break;\r\n            case 'fulfilled':\r\n                this.fulfill(this._result);\r\n                break;\r\n            case 'rejected':\r\n                this.reject(this._result);\r\n                break;\r\n        }\r\n    };\r\n    \r\n    Resolver.prototype._notify = function (subs, result) \r\n    {\r\n        if (subs.length) \r\n        {\r\n            Promise.async(function () \r\n            {\r\n                var i, len;\r\n                for (i = 0, len = subs.length; i < len; ++i) \r\n                {\r\n                    subs[i](result);\r\n                }\r\n            });\r\n        }\r\n    };\r\n\t\r\n    function Promise(fn) \r\n    {\r\n    \tif (!(this instanceof Promise))\r\n    \t{\r\n    \t\tthrow new TypeError('Promises must be constructed via new');\r\n    \t}\r\n    \tif (typeof fn !== 'function')\r\n    \t{\r\n    \t\tthrow new TypeError(\"Promise constructor takes a function argument\");\r\n    \t}\r\n    \tvar resolver = new Resolver();\r\n    \tthis._resolver = resolver;\r\n\r\n        try \r\n        {\r\n            fn(function (value) \r\n            {\r\n                resolver.resolve(value);\r\n            }, \r\n            function (reason) \r\n            {\r\n                resolver.reject(reason);\r\n            });\r\n        } \r\n        catch (e) \r\n        {\r\n            resolver.reject(e);\r\n        }\r\n    }\r\n        \r\n    Promise.prototype.then = function (callback, errback) \r\n    {\r\n    \tvar resolve, reject,\r\n        promise = new this.constructor(function (res, rej) \r\n        {\r\n            resolve = res;\r\n            reject = rej;\r\n        });\r\n\r\n\t    this._resolver._addCallbacks(typeof callback === 'function' ? Promise._makeCallback(promise, resolve, reject, callback) : resolve,\r\n\t        typeof errback === 'function' ? Promise._makeCallback(promise, resolve, reject, errback) : reject);\r\n\r\n\t    return promise;\r\n    };\r\n    \r\n    Promise.prototype[\"catch\"] = function(errback) \r\n    {\r\n    \treturn this.then(undefined, errback);\r\n    };\r\n    \r\n    Promise.resolve = function (value) \r\n    {\r\n        if (value && value.constructor === this) \r\n        {\r\n            return value;\r\n        }\r\n        return new this(function (resolve) \r\n        {\r\n            resolve(value);\r\n        });\r\n    };\r\n    \r\n    Promise.reject = function (reason) \r\n    {\r\n        var promise = new this(function () {});\r\n       promise._resolver._result = reason;\r\n       promise._resolver._status = 'rejected';\r\n\r\n       return promise;\r\n    };\r\n    \r\n    Promise.all = function (values) \r\n    {\r\n        var Promise = this;\r\n        var util = new NSUtil();\r\n        return new Promise(function (resolve, reject) \r\n        {\r\n            if (!util.isArray(values)) \r\n            {\r\n                reject(new TypeError('Promise.all expects an array of values or promises'));\r\n                return;\r\n            }\r\n\r\n            var remaining = values.length,\r\n                i         = 0,\r\n                length    = values.length,\r\n                results   = [];\r\n\r\n            function oneDone(index) \r\n            {\r\n                return function (value) \r\n                {\r\n                    results[index] = value;\r\n\r\n                    remaining--;\r\n\r\n                    if (!remaining) \r\n                    {\r\n                        resolve(results);\r\n                    }\r\n                };\r\n            }\r\n\r\n            if (length < 1) \r\n            {\r\n                return resolve(results);\r\n            }\r\n\r\n            for (; i < length; i++) \r\n            {\r\n                Promise.resolve(values[i]).then(oneDone(i), reject);\r\n            }\r\n        });\r\n    };\r\n    \r\n    Promise.race = function (values) \r\n    {\r\n        var Promise = this;\r\n        var util = new NSUtil();\r\n        return new Promise(function (resolve, reject) \r\n        {\r\n            if (!util.isArray(values)) \r\n            {\r\n                reject(new TypeError('Promise.race expects an array of values or promises'));\r\n                return;\r\n            }\r\n            for (var i = 0, count = values.length; i < count; i++) \r\n            {\r\n                Promise.resolve(values[i]).then(resolve, reject);\r\n            }\r\n        });\r\n    };\r\n    \r\n    Promise.async = typeof setImmediate !== 'undefined' ?\r\n            function (fn) {setImmediate(fn);} :\r\n        typeof process !== 'undefined' && process.nextTick ?\r\n            process.nextTick :\r\n        function (fn) {setTimeout(fn, 0);};\r\n    \r\n    Promise._makeCallback = function (promise, resolve, reject, fn) \r\n    {\r\n        return function (valueOrReason) \r\n        {\r\n            var result;\r\n            try \r\n            {\r\n                result = fn(valueOrReason);\r\n            } \r\n            catch (e) \r\n            {\r\n                reject(e);\r\n                return;\r\n            }\r\n            if (result === promise) \r\n            {\r\n                reject(new TypeError('Cannot resolve a promise with itself'));\r\n                return;\r\n            }\r\n            resolve(result);\r\n        };\r\n    };\r\n    \r\n    Promise.Resolver = Resolver;\r\n    \r\n    var globalNS = (function() \r\n    {\r\n    \t  if (typeof self !== 'undefined') {\r\n    \t    return self;\r\n    \t  }\r\n    \t  if (typeof window !== 'undefined') {\r\n    \t    return window;\r\n    \t  }\r\n    \t  if (typeof global !== 'undefined') {\r\n    \t    return global;\r\n    \t  }\r\n    \t  throw new Error('unable to locate global object');\r\n    })();\r\n    \r\n    if (typeof globalNS['Promise'] !== 'function') \r\n    {\r\n    \tglobalNS['Promise'] = Promise;\r\n    }\r\n    else\r\n    {\r\n    \tPromise = globalNS['Promise'];\r\n    }\r\n    \r\n    return Promise;\r\n}());\r\nnsModuleExport(this,\"Promise\",Promise);";